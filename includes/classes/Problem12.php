<?php
/**
 * Project Euler - Problem 12
 *
 * Highly divisible triangular number
 *
 * The sequence of triangle numbers is generated by adding the natural numbers. 
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
 * The first ten terms would be:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * 
 * Let us list the factors of the first seven triangle numbers:
 *  1: 1
 *  3: 1,3
 *  6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 * 
 * What is the value of the first triangle number to have over five hundred divisors?
 *
 * @category ProjectEuler
 * @package Problem12
 * @author Michael Reeves <mike.reeves@gmail.com>
 * @link http://projecteuler.net/problem=12
 *
 */
class Problem12 extends Problem_Abstract
{

    /**
     * Project Euler says each problem should take no more than 1 minute. If your computer is slow make this larger.
     * $const int PROBLEM_TIMEOUT Used with set_timeout_limit to throw a timeout if problem computation takes too long.
     */
    const PROBLEM_TIMEOUT_OVERRIDE = 60;

    /**
     * Description of input
     * @const string INPUT
     */
    const INPUT = 500;

    /**
     * Override default timeout of 60 seconds
     */
    public function __construct()
    {
        set_time_limit(self::PROBLEM_TIMEOUT_OVERRIDE);
        if (!extension_loaded('bcmath')) {
            // Placeholder for any extensions required for this problem's code
            // die('BCMath extension required. See http://www.php.net/manual/en/book.bc.php .');
        }
    }

    /**
     * Wrapper method to output our answer with the appropriate input variables
     *
     * @return int
     */
    public function execute()
    {
        return $this->findTriangleNumber(self::INPUT);
    }


    /**
     * Find a "Triangle Number" with more than $divisorCount divisors.
     *
     * @param string $divisorCount description
     *
     * @return int description
     */
    private function findTriangleNumber($divisorCount) {
        $t1 = time(true);
        $count = 0;
        $triangleIndex = 1;
        $triangleNumber = 0;
        while ($count < $divisorCount){
            $triangleNumber += $triangleIndex; 
            $count = self::countDivisors($triangleNumber);
            $triangleIndex++;
        }       
        $t2 = time(true);
        return "time elapsed: ".round(($t2 - $t1), 4)." answer: ".$triangleNumber;
    }

    /**
     * count divisors for a number
     *
     * Algoritm taken from here: 
     * http://mathforum.org/library/drmath/view/55843.html
     * x^a * y^b * z^c .... n^d
     * divisor count = (a+1) * (b+1) * (c+1)
     */
    private function countDivisors($number) {
        $pf = $this->findPrimeFactors($number);
        $count = 1;
        foreach ($pf as $k=>$v) {        
            $count *= ($v+1);
        }
        // echo $number.": ".$count."\n"; // debug
        // echo "prime factors: ".var_export($pf, true)."\n"; //debug

        return $count;
    }

    /** 
     * count divisors for a number
     *
     * brute force method
     */
    private function countDivisors2($number) {
        $count = 1; // this is the number itself since we only go to number/2
        $numbers = array($number);
        for ($i = 1; $i <= $number/2; $i++) { // can be optimized further?
            if ($number % $i === 0) {
                $count++;
                $numbers[] = $i;
            }
        }
        // echo $number." : ".$count."\n"; // debug
        // echo "divisors: ".implode(", ",$numbers)."\n"; // debug

        return $count;
    }

    /**
     * Test if a number is prime.
     * .
     * @param int $number test if this number is prime
     *
     * @return bool
     */
    private function isPrime($number){
        if ($number < 2){
            return false;
        } elseif ($number === 2){
            return true;
        } elseif ($number % 2 === 0) {
            return false;
        }
        $upperBound = ceil(sqrt($number));

        for ($j = 3; $j <= $upperBound; $j = $j + 2) {
            if ($number % $j === 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Find prime factors of a number.
     *
     * @param string $number number to find prime factors of
     *
     * @return associative array of prime factors with their exponent
     */
    private function findPrimeFactors($number){
        $i = 2;
        $primeFactors = array();
        while ($number > 1) {
            if (($number % $i === 0) && $this->isPrime($i)) {
                $primeFactors[$i] = (isset($primeFactors[$i])) ? $primeFactors[$i]+1 : 1;
                $number = $number/$i;
                continue;
            }
            $i++;
        }
        return $primeFactors;
    }
}
